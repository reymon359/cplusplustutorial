/*Preprocessor directives
Preprocessor directives are lines included in the code of programs preceded by a hash sign (#). These lines are not
program statements but directives for the preprocessor. The preprocessor examines the code before actual compilation
of code begins and resolves all these directives before any code is actually generated by regular statements.

These preprocessor directives extend only across a single line of code. As soon as a newline character is found, the
preprocessor directive is ends. No semicolon (;) is expected at the end of a preprocessor directive. The only way a
preprocessor directive can extend through more than one line is by preceding the newline character at the end of the
line by a backslash (\).

macro definitions (#define, #undef)
To define preprocessor macros we can use #define. Its syntax is:

#define identifier replacement

When the preprocessor encounters this directive, it replaces any occurrence of identifier in the rest of the code by replacement.
This replacement can be an expression, a statement, a block or simply anything. The preprocessor does not understand C++ proper,
it simply replaces any occurrence of identifier by replacement.

#define TABLE_SIZE 100
int table1[TABLE_SIZE];
int table2[TABLE_SIZE];

After the preprocessor has replaced TABLE_SIZE, the code becomes equivalent to:

int table1[100];
int table2[100];

#define can work also with parameters to define function macros:

#define getmax(a,b) a>b?a:b

This would replace any occurrence of getmax followed by two arguments by the replacement expression, but also
replacing each argument by its identifier, exactly as you would expect if it was a function:*/

// function macro
#include <iostream>
using namespace std;

#define getmax(a,b) ((a)>(b)?(a):(b))

int main()
{
  int x=5, y;
  y= getmax(x,2);
  cout << y << endl;
  cout << getmax(7,x) << endl;
  return 0;
}
/* Defined macros are not affected by block structure. A macro lasts until it is undefined with the #undef
preprocessor directive:

#define TABLE_SIZE 100
int table1[TABLE_SIZE];
#undef TABLE_SIZE
#define TABLE_SIZE 200
int table2[TABLE_SIZE];

This would generate the same code as:

int table1[100];
int table2[200];

Function macro definitions accept two special operators (# and ##) in the replacement sequence:
The operator #, followed by a parameter name, is replaced by a string literal that contains the argument passed (as
if enclosed between double quotes):

#define str(x) #x
cout << str(test);

This would be translated into:

cout << "test";

The operator ## concatenates two arguments leaving no blank spaces between them:

#define glue(a,b) a ## b
glue(c,out) << "test";

This would also be translated into:

cout << "test";

Because preprocessor replacements happen before any C++ syntax check, macro definitions can be a tricky feature. But, be careful:
code that relies heavily on complicated macros become less readable, since the syntax expected is on many occasions different from
the normal expressions programmers expect in C++.*/
