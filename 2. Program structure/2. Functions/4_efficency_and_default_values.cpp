/* Efficiency considerations and const references
Calling a function with parameters taken by value causes copies of the values to be made.
This is a relatively inexpensive operation for fundamental types such as int, but if the parameter
is of a large compound type, it may result on certain overhead. For example, consider the following function:

string concatenate (string a, string b)
{
  return a+b;
}

This function takes two strings as parameters (by value), and returns the result of concatenating them.
By passing the arguments by value, the function forces a and b to be copies of the arguments passed
to the function when it is called. And if these are long strings, it may mean copying
large quantities of data just for the function call.

But this copy can be avoided altogether if both parameters are made references:

string concatenate (string& a, string& b)
{
  return a+b;
}

Arguments by reference do not require a copy. The function operates directly on (aliases of)
the strings passed as arguments, and, at most, it might mean the transfer of certain pointers
to the function. In this regard, the version of concatenate taking references is more efficient
 than the version taking values, since it does not need to copy expensive-to-copy strings.

On the flip side, functions with reference parameters are generally perceived as functions that
 modify the arguments passed, because that is why reference parameters are actually for.

The solution is for the function to guarantee that its reference parameters are not going to be
 modified by this function. This can be done by qualifying the parameters as constant:

string concatenate (const string& a, const string& b)
{
  return a+b;
}

By qualifying them as const, the function is forbidden to modify the values of neither a nor b,
 but can actually access their values as references (aliases of the arguments), without having
  to make actual copies of the strings.

Therefore, const references provide functionality similar to passing arguments by value, but with
an increased efficiency for parameters of large types. That is why they are extremely popular in
 C++ for arguments of compound types. Note though, that for most fundamental types, there is no
 noticeable difference in efficiency, and in some cases, const references may even be less efficient!

Inline functions
Calling a function generally causes a certain overhead (stacking arguments, jumps, etc...), and thus
 for very short functions, it may be more efficient to simply insert the code of the function where
    it is called, instead of performing the process of formally calling a function.

Preceding a function declaration with the inline specifier informs the compiler that inline expansion
is preferred over the usual function call mechanism for a specific function. This does not change at
all the behavior of a function, but is merely used to suggest the compiler that the code generated by
the function body shall be inserted at each point the function is called, instead of being invoked with
a regular function call.

For example, the concatenate function above may be declared inline as:

inline string concatenate (const string& a, const string& b)
{
  return a+b;
}

This informs the compiler that when concatenate is called, the program prefers the function to be expanded
inline, instead of performing a regular call. inline is only specified in the function declaration, not when
it is called.

Note that most compilers already optimize code to generate inline functions when they see an opportunity to
improve efficiency, even if not explicitly marked with the inline specifier. Therefore, this specifier merely
indicates the compiler that inline is preferred for this function, although the compiler is free to not inline
it, and optimize otherwise. In C++, optimization is a task delegated to the compiler, which is free to generate
any code for as long as the resulting behavior is the one specified by the code.

Default values in parameters
In C++, functions can also have optional parameters, for which no arguments are required in the call, in such a
way that, for example, a function with three parameters may be called with only two. For this, the function shall
include a default value for its last parameter, which is used by the function when called with fewer arguments. For example: */

// default values in functions
#include <iostream>
using namespace std;

int divide (int a, int b=2)
{
  int r;
  r=a/b;
  return (r);
}

int main ()
{
  cout << divide (12) << '\n';
  cout << divide (20,4) << '\n';
  return 0;
}
/*In this example, there are two calls to function divide. In the first one:

divide (12)

The call only passes one argument to the function, even though the function has two parameters. In this case,
the function assumes the second parameter to be 2 (notice the function definition, which declares its second
parameter as int b=2). Therefore, the result is 6.

In the second call:

divide (20,4)

The call passes two arguments to the function. Therefore, the default value for b (int b=2) is ignored, and b takes t
he value passed as argument, that is 4, yielding a result of 5.*/
